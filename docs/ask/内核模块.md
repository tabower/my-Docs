# 内核模块

本文我们来探讨下是如何让我们的小内核支持与“内核模块”类似的功能的。



**严格来说，我们实现的功能只是动态链接，只不过这个动态链接是直接链接到了内核函数而已，且自身在内核空间执行**。为了下文的称呼方便，我们还是以“内核模块”来称呼。



那么首先，回想我们在LInux环境下写内核模块的时候，我们是先写代码的时候把内核头文件也引用进来，然后哐哐一堆内核函数使用，最后进行编译，使用命令插入内核即可。



另外，我们似乎还听说过一个“导出”的功能？基础的导出功能由`EXPORT_SYMBOL`提供。这个和引用头文件啥关系呢？而且话说起来，如果我们使用没有被导出的符号，就算我们有声明，那编译结果又会怎样呢？



关于“引用头文件”和“导出”，我说一下自己的理解：

- “引用头文件”：这个玩意儿是为了使用外部的函数`A`，告诉编译器，编译（这里是转成汇编文件那个狭小的）的时候给`A`那里留个位置，我现在暂时不知道函数`A`的地址，后面等链接的时候再补上。整个过程发生在编译（这个“编译”指的是整个流程，不是那个狭小的“编译”）阶段，由链接器实现重定位。
- “导出”：内核自身是一个完备的实体，在运行过程而不是编译过程中，需要有第三方模块动态插入，那么第三方模块必须要知道我引用内核函数的地址。也就是说，内核会把某些函数的地址记账下来，到时候有人需要就来查这个表，然后告诉那个模块地址是多少，这样的函数称为是被导出的函数。这样，第三方模块被插入内核后才能快乐地运行。对于没有导出的符号，也就是内核没有记录地址，那么就算你引用了头文件，或者显式extern某些内核符号，看似来似乎解决了“IDE”给你说的找不到符号的报错提示，最后一对账，哦豁，这个函数根本就不允许外部使用。



// TODO