# 虚存管理

本节我们来描述对于虚存的管理部分。

整个系统的虚存管理位于 `kernel/vm`目录下。

这里我们仅大致描述下其主要框架，并结合一个用户程序运行的小示例进行分析。





## 1. 虚存分布

我们先来看看虚存空间的分布情况吧，直接看用户虚存即可。如下图所示：

```
用户程序虚存分布：

参见
    /include/conf.h
    /boot/kernel.ld
    /user/user.ld

0xFFFFFFFFF ┌─────────────────────────────────────────────────────────┐
            │  USER_MAP_TOP (0xFFFFFFFFF)                             │
            │  [动态内存映射区]                                         │
            │  范围: 0xA00000000 ~ 0xFFFFFFFFF                         │		SEG6
            │  (USER_MAP_BOTTOM ~ USER_MAP_TOP)                       │
            │  用途: mmap/heap/共享库等                                 │
0xA00000000 ├─────────────────────────────────────────────────────────┤
            .
   			.
   			.
            │  ├─ .eh_frame (异常处理帧)                                │
            │  ├─ .bss (未初始化数据, RW-)                              │
            │  ├─ .data (已初始化数据, RW-)                             │
            │  ├─ .rodata (只读数据, R--)                              │
            │  ├─ .text (代码段, R-X)                                  │		SEG5
            │  PROVIDE(uend = .)  // 程序结束地址                       │
            │  USER_TEXT_BASE = 0x200000000                           │
            │  [用户代码与数据段] (链接脚本定义)                           │
            │                                                         │
0x200000000 ├─────────────────────────────────────────────────────────┤
0x1FFFFF000 ├─────────────────────────────────────────────────────────┤
            │  [线程栈区] (向下增长)                                     │
            │  USER_STACK_TOP(tid) =                                   │
            │     0x200000000 - 0x1000 - tid*(USER_STACK_SIZE+4K) - (8)│		SEG4
            │  ├─ 每个线程栈大小: 8MB (USER_STACK_SIZE)                  │
            │  ├─ 栈间隔离: 4K guard page                               │
            │  (tid=0 的栈顶: 0x200000000 - 0x1000 - 8 ≈ 0x1FFFFF000)   │
          	.
    		.
    		. 
            ├─────────────────────────────────────────────────────────┤
            │                                                         │
            │  (固定占用 1页 + 4页参数页)                                │
            │  ├─ 环境变量字符串(暂未实现)                                │
            │  ├─ 参数字符串 (如 "./a.out")                             │			SEG3
            │  ├─ 参数指针表 (char* argv[])                             │
            │  USER_ARGS_PAGE = 0x150000000                           │
            │  [参数与环境变量区]                                        │
0x150000000 ├─────────────────────────────────────────────────────────┤
   			.
   			.
   			.                                                                  
           ├─────────────────────────────────────────────────────────┤   
           │          用户入口、出口    start.s          user_entry    │
           │                  1. jalr elf.entry                      │
           │                  2. exit(0)                             │
           │   所有用户共享，为了简单，直接映射到内核，用户可访问            │
内核代码段中 ├─────────────────────────────────────────────────────────┤
 		   ├                 内核的text,radata,data                   ┤		SEG2
0x80000000 ├─────────────────────────────────────────────────────────┤
           │                用于内核模块映射                            │		 SEG1
0x70000000 ├─────────────────────────────────────────────────────────┤


; 好吧，其实不一定从 0x200,000,000开始代码都行，我们的内核做了一些小适配
; 核心是入口函数 user_entry 跳转到你的开始位置，
; 开始位置由 elf.entry给出，也就是user.ld的起始地址
; 我们只是为了方便一统。我们将参数与栈放在这里放好固定了。
; 其余的，如果按照我们的 user.ld 来的话，将代码起始地址放在
;  0x1FFFFF000 和 0xA00000000 之间都行（需要页对齐）
; 如果靠近 0xA00000000 的话，需要注意越界。
; 其它空间最好别乱搞，我也不知道后面内核会拿某一块空间干莫事
```

上面就是我们对于一个用户程序而言的一个完整的虚存分布。

我们来从下往上逐一解释(SEG 1 ~ SEG6)：

### 内核空间

#### SEG1

本区域位于 `0x70_000_000` -  `0x80_000_000 - 1`，大小合计256M。

```c
// kernel/module/module.c
#define MOD_BASE 0x70000000
```

本区域是我们用来当做内核模块的映射。当一个内核模块被插入内核的时候，会把模块的所有段一次性载入（为了避免不必要的麻烦，我们不是很想在内核模块运行中发生缺页）。这一块空间可以插入多个内核模块，模块与模块挨着存放。每个模块空间包含连续的代码、数据等段。



> 注：本段起始地址 MOD_BASE 没有作为配置直接存在`conf.h`，因为这个地址的选择需要满足一定的条件。
>
> 比如：我们编译的时候根据编译选项汇编出 auipc + jalr 的函数跳转方式，但这个跳转只能跳转+-2G的地址。如果需要跳转到导出的内核函数，那么当前的位置与内核函数的位置差距有一定限制。尽管SV39只用了39位而不是64位，不过那也很大了，随随便便超而导致不可跳转。我们担心“认为随便配的一块空间就好”的想法，因此单独写在这个源文件。

#### SEG2

本区域从 `0x80_000_000` - `0x150_000_000 -1`，大小合计3.25G。

本区域用于放置编译后的内核代码，数据等空间，且连续存放。目前我们的内核自身大小至少远远达不到这个最大的3.25G，因此不必考虑被撑爆导致压着后面的东西。

值得注意的是，**这一块空间有用户程序的入口和出口函数，是用户空间的特例，允许用户访问**。这是我们为了简化操作，将所有函数的入出口都放在一个内核页表，我们能确保这一段空间绝对小于一个页面。这样对于用户而言，共用一个出入口函数段。这样用户程序在建立的时候，由于内核空间也被映射到用户空间，而内核页表是大家共用的，节省了在每个用户程序增加这一块虚存的管理步骤。

最初我们没有加上这一块空间，导致了即使能跳转到用户的`main`函数入口，但是退出`main`函数的时候必须要显式的用`return`,加上这一段之后，相当于允许用户不显式`return`也行。

当然这样做在实际中会带来一些问题，但是至少我们暂时不用考虑。



### 用户空间

#### SEG3

本区域从`0x150_000_000`-  `conf`，具体空间由`conf.h`配置,相关的参数见：

```c
// 用户参数页列表占用 1 页(最多 4096 / 8 = 512 个参数，显示包含最后一个 NULL)
// (暂时固定，要改的话需要该代码 parse_argv )
#define USER_ARGS_MAX_CNT 1

#define USER_ARGV_MAX_SIZE 4                         // 用户参数页大小 4 个页
#define USER_ARGV_MAX_CNT (PGSIZE / sizeof(char *))  // 最大参数个数
#define USER_ARGS_PAGE 0x150000000
```

这一段区域主要用于程序的**环境变量**与**参数**配置。目前我们仅仅实现用于了`exec`加上**参数**传递给新的启动程序。

#### SEG4

本区域从`0x1FFFFF000 - 8`为栈顶，可配置，往下生长。

```c
#define USER_STACK_SIZE (8 * 1024 * 1024)                                                      // 8 MB 栈
#define USER_STACK_TOP(tid) (USER_TEXT_BASE - 0x1000 - (tid) * (USER_STACK_SIZE + 0x1000) - 0x8)  // 用户程序栈顶
```

我们的内核为多线程提供了基础，但是并没有实现（你可以认为是在画饼，哈哈）。我们采取的是比较传统的**进程分配资源，线程作为执行单位**，而不是Linux中直接对于共享资源的使用。每个线程有自己的tid（thread id），分别从0开始编号。启动线程，或者说main函数所在的线程执行流，tid为0，当新增线程的时候，会分配新的`thread_info`，并tid递增分配。根据tid的不同，向下选择不同的栈，计算公式为如上，这样每个线程就有自己独立的用户栈。

#### SEG5

本区域从`0x200_000_000 `开始，同样，这个值是可配置的。

```c
#define USER_TEXT_BASE 0x200000000                                                   // 用户程序段基地址 
```

这一段区域用于用户程序的代码，数据，且连续存放。

需要注意的就是：用户的代码，数据等段必须要按页（PGSIZE）对齐。这是我们后面的虚存管理的基础。

> 这个内核很小，也仅仅是自己搞来玩，导致内核代码缺少中相关的检测对齐函数，没有如果没对齐，那我也不知道会发生什么，也懒得故意去测试\^_^。

#### SEG6

本段区域`0xA00_000_000` - `0xFFF_FFF_FFF`，空间挺大的，这里就不算了。

```c
#define USER_MAP_TOP 0xFFFFFFFFF     // 用户映射区顶
#define USER_MAP_BOTTOM 0xa00000000  // 用户映射区域底
```

我们目前这一块空间只用于实现了 `mmap`函数把文件映射进入内存，并没有其他什么额外的操作。对于以后的用户堆空间啥的，动态链接库啥的（如果有的话），看到时候再用这一段空间。



## 2. 虚存管理框架



### 2.1 SV39

<img src="https://r2-pub.tbw.wiki/piclist/2025/06/269e999383d73e25dd165231fe3eedac.png" alt="image-20250619141017889" style="zoom:33%;" />

### 2.2 **Manage** 

TODO
