# 进程信号

这一节，我们来谈一谈我们的小内核进程之间的通信手段——信号。

我们会涉及到信号的实现、发送、接收处理、以及一个类似于`sigaction`的系统调用（自定义信号处理函数）。

> 当初写的时候有点迷糊，代码中好多相关结构体名字命名挺乱的。。。



信号可以大致分为以下两类：

- 标准信号

传统的Unix信号，范围 1~31。以查看某一位是否为`1`/`0`即可知道有没有该信号。

**不支持排队，也就是说，多个相同的信号会被合并为一个**，这也是标准信号最大的特点。

常见的`SIGINT`、`SIGQUIT`、`SIGKILL`、`SIGCHLD`等都属于这一类

- 实时信号

范围32~64，支持排队、优先级、附加数据、可靠传递（也就是不会丢失，不会被合并，一个一个处理）。



> 在我们的实现中，
>
> 标准信号采用 `sigset_t（uint32_t）` 实现，每一位代表一种信号；
>
> 实时信号我们为了简化，仅仅顺序先来先服务，采用队列实现。每个`siginfo_t`直接作为实时信号，其`info`字段表示信号种类，没有其他什么额外的东西；
>
> （命名不规范的很多，这里只是冰山一角，哈哈) 





## 1. 信号实现

这一部分比较简单（当然了，其实只是我们实现功能很又少又简陋而已。。。）

```c
// include/core/signal.h

typedef uint32_t sigset_t;
// 信号处理函数类型
typedef void (*__sighandler_t)(int);

// 信号处理配置结构体
struct sigaction {
	__sighandler_t sa_handler; 
};

// siga 存放信号处理函数
struct signal_struct {
    spinlock_t lock;
	struct sigaction siga[_NSIG];
};

// 实时信号（加入 sigpending->sigpending.queue队列）
typedef struct {
	struct list_head list;
	uint8_t info;			// 信号信息
} siginfo_t;

// 待处理的信号
struct sigpending {
	struct fifo queue; 	// 实时信号
	sigset_t signal;	// 标准信号
	sigset_t blocked;	// 阻塞信号
};

// 信号管理（task_struct->signal）
struct signal {
	spinlock_t lock; // 用于处理信号标准合并导致的 sigpend 数量不对的问题
	uint32_t sigpend;
    struct sigpending sping;
	struct signal_struct *sig;
};
```

下面是对一些结构体的简答解释：

- `signal`：管理信号，包括处理函数与存放信号（被`task_struct`直接使用）

- `sigpending`：存放信号，包括标准和实时信号
- `siginfo_t`：实时信号
- `signal_struct`：存放信号处理函数

想必我们到了这里，已经大概知道了信号实现。（没错，我们仅仅实现了这微不足道的一点，哈哈）





## 2. 发送

这一部分也比较简单。伪代码如下（省去一堆错误检测处理）：

```c
// kernel/proc/signal.c
void send_sig(int sig, pid_t pid)
{
    // 检测信号合法性
    detect_sig_valid(sig);
    
    // 找到对应的进程
     p = find_proc(pid);
    
    // 检测信号是否被该程序堵塞
    is_blocked(p,sig);
    
    // 添加信号
    add_signal(p,sig);
}
```





## 3. 接收和处理

接收之后如果有的话就要处理，那么问题来了，进程检测信号有无的时机在哪里呢？

我们便也顺着古人的路子，采用程序主动查询方式。只不过可不是单独派一个玩意儿来监视。

具体来说：我们在程序**中断即将返回**的时候查看信号。为了不是遍历整个信号清单来查有没有待决信号，我们设置标志位来判断是否含有信号。当我们发现有信号的时候，并移除信息，就完成了对信号的接收。

下面就要根据信号编号在`siga`中找到对应的处理函数了。这里就是需要我们注意的地方。对于系统提供的默认函数，直接执行貌似没有问题的。但是呢，对于用户自定义的函数，这里就有问题了。什么问题呢？

**用户自定义的函数位于用户虚存空间，而系统自定义的位于内核空间**。前面我们说到，我们是在**中断即将返回**的时候检查并处理信号，那此时的我们，是位于**内核态**的，而且还拖着一堆中断的备份信息呢。就算我们回到用户自定义的函数，这个函数返回的时候会返回到哪里呢（绝不可能一个`return`返回到内核空间，因为我们执行的时候位于用户态）？就算我们不管一切，直接执行用户自定义的函数，假如再中断？原中断的备份信息如何保存？如何回答到第一次中断回去的断点处呢？

因此，由于有**用户自定义的信号处理函数**这个拦路虎在，看来我们的执行并不会是一帆风顺。

下面我们给出解决办法。



## 4. sigaction
