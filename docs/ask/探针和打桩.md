# 探针和打桩

> 此节的实现和[函数约定](./函数约定(RV64).md)密不可分

本文来谈一谈我们小内核已实现的两种简单技术：探针和打桩

我们实现的功能特别少，很简单，功能如下：



- 探针：在被探函数`A`前执行我们自己的函数`B`，返回后**继续执行**`A`。

一般可用于监控函数`A`，函数`B`会收到和函数`A`一样的参数，同时我们保证了`B`返回后寄存器都是原来的值。也就是说，`B`对于`A`是透明的，`A`察觉不到自己前面还有一个**窃听者**。

当然，如果愿意，只需要稍改代码，不恢复寄存器的值也行，甚至还可以故意修改寄存器，这样`A`收到的参数就是被改过的参数，这样的`B`很类似于网络安全中的`中间人`。



- 打桩：我们采用**破坏性侵入**代码，替换`A`该而执行我们自己的函数`B`。当其他地方函数`C`调用函数`A`时，其实会运行我们的函数`B`，且函数`B`返回后直接返回`C`。

  

由于我们已经实现了简单的[内核模块](./内核模块.md)，实现这个仅仅是为了允许我们运行时动态监控或修改内核。





## 1. 探针

> 如果需要启用该功能，需要添加配置编译选项后重新编译

有个`A->B`，在编译后，`A`中的call `B`会直接编译成对 `B`的地址跳转。

如果不做任何处理，编译后的汇编代码都是紧紧挨在一起，密不可分，也就是说 `B` 函数前前后后都是代码，严丝合缝（牛角尖就不要来了哈，什么开头一个和最后一个函数啥的，在链接脚本中单独配置函数分布啥的拉都不考虑。。。。）。那么如何让`A`先跳到我们自己插入的函数呢？

一种办法是在运行过程中直接修改`A`的二进制代码，显然是不可取的。先不论大家`A,Z,X,V,B,N,M...`调用`B`最后汇编代码的实现都不一样，就算都一样，其他大家伙也还是没有变啊，就算大家都能变，你能知道有哪些地方调用了这个`B`吗，难不成？？？

所以为了实现，只能在被调用者`B`上面下功夫。

此外，我们还受限于这两个下面的两个条件：

1. 不能破坏`B`（或者先破坏后复原）
2. 所有代码密不可分



// TODO





## 2. 打桩



// TODO